r"""
Auto generation of Cython files that deal with polymake properties
and small types

This functions in this file are called by setup.py
"""

from __future__ import print_function

import json
import os


header = "# This file was autogenerated! Do not modify!\n"

handler = """
# {pytype} {pmtype}
cdef extern from "wrap.h" namespace "polymake":
    void pm_give_{pytype} "GIVE" (pm_{pytype}, pm_PerlObject*, string) except +
    void pm_call_method_{pytype} "CALL_METHOD" (pm_{pytype}, pm_PerlObject*, string) except +

def give_{pytype}(PerlObject perl_object, bytes prop):
    cdef {pytype} ans = {pytype}.__new__({pytype})
    pm_give_{pytype}(ans.pm_obj, perl_object.pm_obj, prop)
    return ans

def call_method_{pytype}(PerlObject perl_object, bytes prop):
    cdef {pytype} ans = {pytype}.__new__({pytype})
    pm_call_method_{pytype}(ans.pm_obj, perl_object.pm_obj, prop)
    return ans
"""

line_give_map = "    b\"{pmtype}\"{spacing} : give_{pytype},\n"
line_call_method_map = "    b\"{pmtype}\"{spacing} : call_method_{pytype},\n"

decl_imports="""
from libcpp cimport bool
from libcpp.string cimport string

from .defs cimport *
"""

class_decl="""
# {pytype} wrapper for {pmtype}
from .defs cimport pm_{pytype}

cdef class {pytype}(object):
    cdef pm_{pytype} pm_obj
"""

def_imports="""
from libcpp.string cimport string
cdef extern from "<sstream>" namespace "std":
    cdef cppclass ostringstream:
        string str()
"""

class_def="""
from .defs cimport pm_{pytype}

cdef extern from "wrap.h" namespace "polymake":
    void pm_{pytype}_repr "WRAP_wrap_OUT" (ostringstream, pm_{pytype})

cdef class {pytype}:
    def __repr__(self):
        cdef ostringstream out
        pm_{pytype}_repr(out, self.pm_obj)
        return (<bytes>out.str()).decode('ascii')
"""

# Iteration protocol
# pytype     : SetInt
# pmperltype : Set<Int>
# pmcpptype  : Set<int>
# pysubtype  : int
#
# define a "transformer" as a class method
#     cdef {py_subtype} elt_to_python(self, {pm_subtype} x):
#         return x
# or
#     cdef {py_subtype} elt_to_python(self, {pm_subtype} x):
#         {py_subtype} y = {py_subtype}.__new__({py_subtype})
#         y.pm_obj = x
#         return y
#
# It will greatly simplifies __iter__, __reverse__ and __getitem__

# c : simple container -> defines elt_to_python
# C : complex container -> defines elt_to_python
# l : __len__
# i : __iter__
# r : __reverse__
# g : __getitem__
iter_decl="""
cdef extern from "polymake/{name}.h" namespace "polymake":
    cdef cppclass pm_{pytype}_iterator "Entire<const {pmcpptype}>::iterator":
        void next "operator++" ()
        bool at_end()
        {pysubtype} get "operator*" ()
    cdef pm_{pytype}_iterator entire_{pytype} "entire" (pm_{pytype})
"""
iter_def="""
    def __iter__(self):
        cdef pm_{pytype}_iterator it = entire_{pytype}(self.pm_obj)
        while not it.at_end():
            yield self.elt_to_python(it.get())
            it.next()
"""
len_def="""
    def __len__(self):
        return self.pm_obj.size()
"""
getitem_def="""
    def __getitem__(self, Py_ssize_t i):
        if i < 0:
            i += self.pm_obj.size()
        if i < 0 or i >= pm.obj_size():
            raise KeyError("{pytype} index out of range")
        return self.elt_to_python(self.pm_obj.get(i))
"""

from .pm_types import pm_types
from collections import defaultdict
types = pm_types()
types_by_module = defaultdict(list)
for typ,prop in types.items():
    mod = prop["module"]
    if mod != "none" and mod != "extra_types":
        types_by_module[mod].append((typ, prop["perl"]))

def all_classes():
    for name,vals in types_by_module.items():
        for pytype, pmtype in vals:
            yield {'name': name, 'pytype': pytype, 'pmtype': pmtype}

def write_declarations():
    for name,vals in types_by_module.items():
        with open(os.path.join('polymake', name.lower() + '.pxd'), 'w') as output:
            output.write(header)
            output.write('# ' + name.lower() + '.pxd interfacing ' + name + '.h\n\n')
            for pytype, pmtype in vals:
                output.write(class_decl.format(name=name, pytype=pytype, pmtype=pmtype))

def undefined_small_classes():
    import re
    class_def = re.compile('cdef class (?P<pytype>[a-zA-Z]*)\(object\)', re.MULTILINE)
    undef_classes = {}
    for name,vals in types_by_module.items():
        filename = os.path.join('polymake', name.lower() + '.pyx')
        u = set(x[0] for x in vals)
        with open(filename) as f:
            classes = class_def.findall(f.read())
            print(name, filename, classes)
        u.difference_update(classes)
        undef_classes[name] = u

    return undef_classes

def write_undefined_classes():
    classes = undefined_small_classes()
    for name,vals in types_by_module.items():
        filename = os.path.join('polymake', 'auto_{}.pxi'.format(name.lower()))
        with open(filename, 'w') as output:
            output.write(header)
            output.write(def_imports)
            for pytype,pmtype in vals:
                if pytype in classes[name]:
                    output.write(class_def.format(name=name, pytype=pytype, pmtype=pmtype))

def write_definitions(filename):
    with open(filename, "w") as output:
        output.write(header)
        output.write(def_imports)
        for opts in all_classes():
            output.write(class_def.format(**opts))

def write_handlers(filename):
    r"""
    Write down functions that given a small type
    construct the corresponding Python object with a pointer
    to that small object
    """
    with open(filename, "w") as output:
        output.write(header)
        for opts in all_classes():
            output.write(handler.format(**opts))

def write_mappings(filename):
    with open(filename, "w") as output:
        output.write(header)

        output.write("cdef dict auto_property_handlers = {\n")
        for opts in all_classes():
            opts.update({'spacing': " "*(40 - len(opts['pmtype']))})
            output.write(line_give_map.format(**opts))
        output.write("}\n")

        output.write("cdef dict auto_method_handlers = {\n")
        for opts in all_classes():
            opts.update({'spacing': " "*(40 - len(opts['pmtype']))})
            output.write(line_call_method_map.format(**opts))
        output.write("}\n")

